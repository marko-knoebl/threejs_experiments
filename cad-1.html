<html>
	<head>
		<meta charset="utf-8">
		<title>My first Three.js app</title>
	</head>
	<body>
		<script src="http://threejs.org/build/three.min.js"></script>
		<script src="three.js"></script>
		<script>
		"use strict";
		// a simple viewer with camera controls which has the z-axis vertical
		
		// gui helper functions
		var createButton, addToolButton, createInputField;
		(function() {
			createButton = function(text, onclick) {
				var button = document.createElement('button');
				button.style.margin = '3px';
				button.style.border = '0px';
				button.style.width = '58px';
				button.style.backgroundColor = '#1ba1e2';
				button.style.color = '#ffffff';
				button.style.fontSize = '12';
				button.innerHTML = text;
				button.onclick = onclick;
				return button;
			}
			
			addToolButton = function(tool) {
				var newButton;
				newButton = createButton(tool.name);
				newButton.style.width = '58px';
				newButton.style.height = '58px';
				newButton.style.fontSize = '12';
				newButton.onclick = function() {activateTool(tool);};
				gui.toolSelector.appendChild(newButton);
			}
			
			createInputField = function(type, default_, onchange) {
				var inputField = document.createElement('input');
				inputField.type = type;
				inputField.value = default_;
				inputField.style.borderWidth = '1px';
				inputField.style.borderStyle = 'solid';
				inputField.style.margin = '3px';
				inputField.style.width = '80px';
				if (onchange) {
					inputField.onchange = onchange;
				}
				return inputField;
			};
		})();
		
		var wireGeom, wireMat, wire;
		
		// this object represents the geometric model that is being edited
		var geoDoc;
		(function() {
			geoDoc = {}
			// all geometric objects
			geoDoc.objects = [];
			
			geoDoc.add = function(obj) {
				// add an object to the document and update the view accordingly
				this.objects.push(obj);
				scene.add(obj);
				renderer.render(scene, camera);
			};
			
			geoDoc.rem = function(obj) {
				var index = this.objects.indexOf(obj);
				var toRemove = this.objects.splice(index, 1)[0];
				scene.remove(toRemove);
				renderer.render(scene, camera);
			};
		})();
		
		var lmbdown; // left mouse button down
		
		// initialize gui elements
		var gui = {};
		(function() {
			// set the document style (CSS)
			document.body.style.margin = '0px';
			document.body.style.backgroundColor = '#eeeeee';
			document.body.style.fontFamily = 'Arimo, "Liberation Sans", Arial, Helvetica, sans-serif';
			document.body.style.fontSize = '16';
			
			// vertical split
			gui.leftSidebar = document.createElement('div');
			gui.leftSidebar.style.cssFloat = 'left';
			gui.leftSidebar.style.width = '200px';
			gui.leftSidebar.style.backgroundColor = '#ffffff';
			document.body.appendChild(gui.leftSidebar);
			
			gui.toolSelector = document.createElement('div');
			gui.toolSelector.style.backgroundColor = '#ffffff';
			gui.toolSelector.style.margin = '3px';
			gui.leftSidebar.appendChild(gui.toolSelector);
			
			gui.toolOptionsContainer = document.createElement('div');
			gui.leftSidebar.appendChild(gui.toolOptionsContainer);
			gui.toolOptions = document.createElement('div');
			gui.toolOptions.style.backgroundColor = '#eeeeee';
			gui.toolOptions.style.fontSize = '12';
			gui.toolOptions.style.padding = '10px';
			gui.toolOptionsContainer.appendChild(gui.toolOptions);
			gui.toolButtons = document.createElement('div');
			gui.toolButtons.style.textAlign = 'center';
			gui.toolButtons.style.padding = '6px';
			gui.toolButtons.style.backgroundColor = '#eeeeee';
			var addButton = createButton(
				'Add',
				function() {
					var newObject = preview.clone();
					newObject.material = mainMaterial;
					geoDoc.add(newObject);
					activateTool(selectTool);
				}
			)
			gui.toolButtons.appendChild(addButton);
			var cancelButton = createButton(
				'Cancel',
				function() {
					activateTool(selectTool);
				}
			);
			gui.toolButtons.appendChild(cancelButton);
			gui.toolOptionsContainer.appendChild(gui.toolButtons);
			
			gui.objectDetailsContainer = document.createElement('div');
			gui.objectDetailsContainer.style.display = 'none';
			gui.leftSidebar.appendChild(gui.objectDetailsContainer);
			
			gui.objectDetails = document.createElement('div');
			gui.objectDetails.style.backgroundColor = '#eeeeee';
			gui.objectDetails.style.fontSize = '12';
			gui.objectDetails.style.padding = '10px';
			gui.objectDetailsContainer.appendChild(gui.objectDetails);
			
			gui.objectDetailsButtons = document.createElement('div');
			gui.objectDetailsButtons.style.backgroundColor = '#eeeeee';
			gui.objectDetailsButtons.appendChild(createButton('OK'));
			gui.objectDetailsButtons.appendChild(createButton('Cancel'));
			gui.objectDetailsContainer.appendChild(gui.objectDetailsButtons);
			
			gui.devArea = document.createElement('div');
			gui.leftSidebar.appendChild(gui.devArea);
		})();
		
		// create renderer
		var renderer;
		(function() {
			renderer = new THREE.WebGLRenderer({antialias: true});
			renderer.setClearColor(0xf6f6f6, 1);
			renderer.setSize(window.innerWidth - 200, window.innerHeight);
			renderer.domElement.style.cssFloat = 'right';
			renderer.domElement.style.width = (window.innerWidth - 200).toString() + 'px';
			renderer.domElement.style.height = (window.innerHeight).toString() + 'px';
			document.body.appendChild( renderer.domElement );
		})();
		
		// set up 3d view
		var scene, camera, cameraContainer, renderer, render;
		(function() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 50, (renderer.domElement.clientWidth) / renderer.domElement.clientHeight, 0.1, 1000 );

			// set up the camera so the z-axis is vertical
			camera.rotation.order = 'ZYX';
			camera.rotation.set(Math.PI/2, 0, Math.PI/2);

			// make a container for the newly oriented camera to control its orientation
			cameraContainer = new THREE.Object3D();
			cameraContainer.add(camera);
			cameraContainer.position.set(20, 0, 0);
			cameraContainer.rotation.order = 'ZYX';
			cameraContainer.ang = {'_phi': 0, '_theta': 0};
			Object.defineProperty(cameraContainer.ang, 'phi', {
					get: function() {return cameraContainer.ang._phi;},
					set: function(phi_) {
						var theta_
						cameraContainer.ang._phi = phi_;
						theta_ = cameraContainer.ang._theta;
						cameraContainer.rotation.set(0, -cameraContainer.ang._theta, cameraContainer.ang._phi);
						cameraContainer.position.set(20 * Math.cos(phi_) * Math.cos(theta_), 20 * Math.sin(phi_) * Math.cos(theta_), 20 * Math.sin(theta_));
					}
				}
			);
			Object.defineProperty(cameraContainer.ang, 'theta', {
					get: function() {return cameraContainer.ang._theta;},
					set: function(theta_) {
						var phi_
						cameraContainer.ang._theta = theta_;
						phi_ = cameraContainer.ang._phi;
						cameraContainer.rotation.set(0, -cameraContainer.ang._theta, cameraContainer.ang._phi);
						cameraContainer.position.set(20 * Math.cos(phi_) * Math.cos(theta_), 20 * Math.sin(phi_) * Math.cos(theta_), 20 * Math.sin(theta_));
					}
				}
			);
			scene.add(cameraContainer);
			
			// create grid
			var gridGeom;
			gridGeom = new THREE.Geometry();
			var gridMat = new THREE.LineBasicMaterial({color: 0xdddddd, shading: THREE.FlatShading});
			var i;
			var lineGeom, line;
			for (i = -10; i <= 10; i++) {
				lineGeom = new THREE.Geometry();
				lineGeom.vertices.push(new THREE.Vector3(i, -10, 0));
				lineGeom.vertices.push(new THREE.Vector3(i, 10, 0));
				line = new THREE.Line(lineGeom, gridMat);
				scene.add(line);
			}
			for (i = -10; i <= 10; i++) {
				lineGeom = new THREE.Geometry();
				lineGeom.vertices.push(new THREE.Vector3(-10, i, 0));
				lineGeom.vertices.push(new THREE.Vector3(10, i, 0));
				line = new THREE.Line(lineGeom, gridMat);
				scene.add(line);
			}
			
			// create axes
			var xAxis, yAxis, zAxis;
			xAxis = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), 1.5, 0xaa0000, 0.4, 0.3);
			yAxis = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), 1.5, 0x00aa00, 0.4, 0.3);
			zAxis = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.5, 0x0000aa, 0.4, 0.3);
			xAxis.line.material.linewidth = 2.5;
			yAxis.line.material.linewidth = 2.5;
			zAxis.line.material.linewidth = 2.5;
			scene.add(xAxis);
			scene.add(yAxis);
			scene.add(zAxis);

			// create lights
			var light = new THREE.SpotLight( 0xffffff, 1.5 );
			light.position.set( 400, 500, 2000 );
			light.castShadow = true;
			light.shadowCameraNear = 0;
			light.shadowCameraFar = camera.far;
			light.shadowCameraFov = 50;
			light.shadowBias = -0.00022;
			light.shadowDarkness = 0.5;
			light.shadowMapWidth = 2048;
			light.shadowMapHeight = 2048;
			scene.add( light );
			
			var ambientLight = new THREE.AmbientLight(0x505050);
			scene.add(ambientLight);
		})();
		
		var previewMaterial = new THREE.MeshPhongMaterial({color: 0x0099ee, shading: THREE.FlatShading, ambient: 0x0022ee, transparent: true, opacity: 0.5});
		var mainMaterial = new THREE.MeshPhongMaterial({color: 0x0099ee, shading: THREE.FlatShading, ambient: 0x0022ee});
		
		// set up ray picker
		var projector = new THREE.Projector();
		
		var selectedObject;
		
		var currentInput = {};
		
		// define tools
		var Tool, boxTool, sphereTool, cylinderTool, coneTool, icosahedronTool, selectTool;
		(function() {
			Tool = function(name, inputs, getShape) {
				this.name = name;
				this.inputs = inputs;
				this.getShape = getShape;
			}
			Tool.prototype = new Object(); // This could be left out 
			
			boxTool = new Tool(
				'Box',
				{Depth: 1, Width: 1, Height: 1},
				function() {
					var newObj = new THREE.Mesh(
						new THREE.BoxGeometry(currentInput.Depth, currentInput.Width, currentInput.Height),
						previewMaterial
					);
					newObj.position.set(currentInput.Depth/2, currentInput.Width/2, currentInput.Height/2);
					return newObj;
				}
			);
			
			sphereTool = new Tool(
				'Sphere',
				{Radius: 1},
				function() {
					var newObj = new THREE.Mesh(
						new THREE.SphereGeometry(currentInput.Radius, 24, 18),
						previewMaterial
					);
					return newObj;
				}
			);
			
			cylinderTool = new Tool(
				'Cylinder',
				{Radius: 1, Height: 1},
				function() {
					var newObj = new THREE.Mesh(
						new THREE.CylinderGeometry(currentInput.Radius, currentInput.Radius, currentInput.Height, 24),
						previewMaterial
					);
					newObj.position.y = currentInput.Height/2;
					return newObj;
				}
			);
			
			coneTool = new Tool(
				'Cone',
				{'Bottom Radius': 1, 'Top Radius': 0.5, Height: 1},
				function() {
					var newObj = new THREE.Mesh(
						new THREE.CylinderGeometry(currentInput['Bottom Radius'], currentInput['Top Radius'], currentInput.Height, 24),
						previewMaterial
					);
					newObj.position.y = currentInput.Height/2;
					return newObj;
				}
			);
			
			icosahedronTool = new Tool(
				'Icosah.',
				{Radius: 1,},
				function() {
					var newObj = new THREE.Mesh(
						new THREE.IcosahedronGeometry(currentInput.Radius),
						previewMaterial
					);
					return newObj;
				}
			);
			
			selectTool = new Tool(
				'Select',
				{},
				function() {return new THREE.Mesh(new THREE.Geometry(), new THREE.Material())}
			);
		})();
		
		addToolButton(boxTool);
		addToolButton(sphereTool);
		addToolButton(cylinderTool);
		addToolButton(coneTool);
		addToolButton(icosahedronTool);
		
		var activeTool;
		var preview;
		
		var onInputChange = function() {
			// update the preview
			scene.remove(preview);
			preview = activeTool.getShape();
			scene.add(preview);
			renderer.render(scene, camera);
		};
		
		var onchangeFactory = function(inputName) {
			// create afunction that is to be called when the user changes an input
			return function() {
				currentInput[inputName] = parseFloat(this.value);
				onInputChange();
			};
		};
		
		var activateTool = function(tool) {
			activeTool = tool;
			
			// remove all inputs
			while (gui.toolOptions.firstChild) {
				gui.toolOptions.removeChild(gui.toolOptions.firstChild);
			}
			
			if (tool.name !== 'Select') {
				gui.toolOptions.innerHTML = '<p style="font-size:18px">' + tool.name + ':</p>';
			} else {
				gui.toolOptions.innerHTML = '';
			}
			for (var inputName in tool.inputs) {
				if (tool.inputs.hasOwnProperty(inputName)) {
					var label = document.createElement('div');
					label.innerHTML = inputName;
					gui.toolOptions.appendChild(label);
					currentInput[inputName] = parseFloat(tool.inputs[inputName]);
					gui.toolOptions.appendChild(
						createInputField('number', tool.inputs[inputName], onchangeFactory(inputName))
					);
				}
			}
			if (tool === selectTool) {
				gui.toolButtons.style.display = 'none';
			} else {
				gui.toolButtons.style.display = 'block';
			}
			onInputChange();
		}
		
		var originalPosition = {x: 0, y: 0, z: 0};
		
		var makeSelectionChangedHandler = function(name) {
			return function() {
				selectedObject.position[name] = originalPosition[name] + parseFloat(this.value);
				renderer.render(scene, camera);
			};
		};
		
		var onSelectionChanged = function() {
			if (selectedObject === null) {
				gui.objectDetailsContainer.style.display = 'none';
			} else {
				originalPosition.x = selectedObject.position.x;
				originalPosition.y = selectedObject.position.y;
				originalPosition.z = selectedObject.position.z;
				gui.objectDetailsContainer.style.display = 'block';
				
				
				// remove all inputs
				while (gui.objectDetails.firstChild) {
					gui.objectDetails.removeChild(gui.objectDetails.firstChild);
				}
				
				for (var i = 0; i < 3; i++) {
					var name = ['x', 'y', 'z'][i];
					var label = document.createElement('div');
					label.innerHTML = name;
				
					gui.objectDetails.appendChild(label);
					
					var fn = makeSelectionChangedHandler(name);
					
					var inputField = createInputField(
						'number',
						0,
						fn
					);
					gui.objectDetails.appendChild(inputField);
				}
			}
		};
		
		window.addEventListener(
			'resize',
			function(event) {
				// update aspect ratios and size of the viewer
				camera.aspect = (window.innerWidth - 200) / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize((window.innerWidth - 200), window.innerHeight);
				renderer.render(scene, camera);
				},
			false
		);
		
		// location where the current mouse drag started
		var mouseDragStart = {x:0, y:0, z:0};
		// location of the last mouse position during the current drag
		var mouseDragLast = {x:0, y:0, z:0};

		var mouse2D = new THREE.Vector3(1, 1, 1);

		document.addEventListener(
			'mousedown',
			function(event) {
				mousemoved = false;
				// store the normalized mouse position
				mouseDragLast.x = mouse2D.x;
				mouseDragLast.y = mouse2D.y;
				mouseDragStart.x = mouse2D.x;
				mouseDragStart.y = mouse2D.y;
				if (event.button === 0) {
					lmbdown = true;
				}
			},
			false
		);
		
		// track whether the mouse was moved after the last mousedown to track clicks
		var mousemoved = false;
		
		document.addEventListener(
			'mouseup',
			function(event) {
				if (event.button === 0) {
					lmbdown = false;
				}
			},
			false
		);
		
		renderer.domElement.addEventListener(
			'mouseup',
			function(event) {
				if (event.button === 0) {
					lmbdown = false;
					var distanceMoved = Math.sqrt(Math.pow(mouseDragStart.x - mouse2D.x, 2) + Math.pow(mouseDragStart.y - mouse2D.y, 2));
					if (distanceMoved < 1/50) {
						// the user has not moved the mouse by more than 1/50 of the screen width
						if (activeTool === selectTool) {
							var ray = projector.pickingRay(mouse2D, camera);
							var intersects = ray.intersectObjects(geoDoc.objects);
							if (selectedObject) {
								selectedObject.material = mainMaterial;
							}
							if (intersects[0]) {
								selectedObject = intersects[0].object;
								selectedObject.material = previewMaterial;
							} else {
								selectedObject = null;
							}
							renderer.render(scene, camera);
							onSelectionChanged();
						}
					}
				}
			},
			false
		);
		
		renderer.domElement.addEventListener(
			'mousemove',
			function(event) {
				mousemoved = true;
				mouse2D.x = ((event.clientX-200) / renderer.domElement.width) * 2 - 1;
				mouse2D.y = - (event.clientY / renderer.domElement.height) * 2 + 1;
				var dx, dy;
				dx = mouse2D.x - mouseDragLast.x;
				dy = mouse2D.y - mouseDragLast.y;
				mouseDragLast.x = mouse2D.x;
				mouseDragLast.y = mouse2D.y;
				if (!lmbdown) {
					return;
				}
				cameraContainer.ang.phi -= dx * 150/180*Math.PI;
				cameraContainer.ang.theta -= dy * 150/180*Math.PI;
				renderer.render(scene, camera);
			},
			false
		);
		
		document.addEventListener(
			'keydown',
			function(event) {
				if (event.which === 39) {
					cameraContainer.ang.phi += 0.04;
					renderer.render(scene, camera);
				} else if (event.which === 37) {
					cameraContainer.ang.phi -= 0.04;
					renderer.render(scene, camera);
				} else if (event.which === 38) {
					cameraContainer.ang.theta += 0.04;
					renderer.render(scene, camera);
				} else if (event.which === 40) {
					cameraContainer.ang.theta -= 0.04;
					renderer.render(scene, camera);
				}
			},
			false
		);
		
		// from Javascript: the Definitve Guide, ed 6: 14.6
		window.onerror = function(msg, url, line) {
			if (onerror.num++ < onerror.max) {
				alert('ERROR: ' + msg + '\n' + url + ':' + line);
				return true;
			}
		};
		onerror.max = 3;
		onerror.num = 0;
		
		activateTool(selectTool);
		
		renderer.render(scene, camera);
		</script>
	</body>
</html>